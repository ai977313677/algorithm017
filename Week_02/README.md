### 第二周总结



### 哈希表，映射，集合

哈希表是根据关键码值直接访问数据的，哈希表提供了一个关键码到数组的映射。类比数组，数组是通过索引下标直接访问数组内元素，可以认为，这里的关键码就是索引下标，而数组其实就是一个特殊的哈希表。

但需要区别的是，想要从key（即关键码值）查到对应的value，需要提供一个散列函数F(key)，这个函数F通常是不能直接能够查询value的，而是提供一个将key转换成对应索引（即元素位置）的函数，通过这个位置来找到对应的value。

> 如果F(key) = value，那么这个实际上并不是一个散列函数，更准确的说来，是一种转换的算法（在某些情况下，也可以称为加密算法）。

（初等）函数中，自变量到应变量的映射是1对1的，反之，应变量到自变量的映射关系则是多对1的，所以可以预见，通过散列函数去计算元素位置，会出现（但并不是一定的，比如y=x）多个key通过hash，最终得到相同位置的情况。这时就产生了冲突。

为了解决这种冲突，提出了开放定址法，线性探测法，拉链法以及再哈希（多次哈希）解决冲突。

> Java选用的是拉链法解决哈希冲突。

### 树，二叉树，二叉搜索树

树的定义是递归的，所以树的算法通常可以使用递归来完成。

有几种比较特殊的树：二叉树，斐波那契树，B树，B+树，2-3树，红黑树。

> 二叉树相对其他的树来说，可能并不是效率非常高的树，但是其衍生出来的树是比较多的，如二叉搜索树，败者树等。

二叉搜索树：又称二叉排序树，他是一个动态的有序表，相对于静态有序表来说，他的插入和删除操作通常是在O(logn)时间完成的，静态有序表的增删通常是O(n)的，在查找时，静态有序表需要使用二分查找才能实现在O(logn)的时间复杂度下完成。

> 二叉搜索树的中序遍历是一个有序的序列。

### 堆，二叉堆，图

二叉堆也是一种特殊的堆，类似于树和二叉树的关系。

通常，堆这种数据结构是用来找到一堆数据中的最大值或者最小值的。规定，根结点最大的堆是大顶堆，反之为小顶堆。

> 堆的定义依旧是一个递归。
>
> 二叉堆是一个完全二叉堆，底层是数组实现的。

堆的增加和删除均需要进行一次重建堆的过程，但这个过程是相反的。

向堆中增加一条数据时，自底向上进行一次调整。

删除堆中的一条数据时，自顶向下进行一次调整。

图：在实际工程中，图的使用是比较少的，但是这不是必然的（需要根据实际工程来判断）。就比如在可视化流程中，使用图结构就是必须的。

图是以边集和点集构成的。图的类型主要分两大类：无向图，有向图。

图中主要的算法有DFS，BFS。