深度优先和广度优先遍历是属于图的基本算法，但是在实际使用中，DFS和BFS的用途是比较广的，比如上周所讲的递归和回溯。

输出单链表值的递归算法实际就可以看作一次深度优先搜索（正序和倒序输出链表结点在递归算法中仅仅是调整了输出函数的位置），只是算法中并没有涉及到更多的可能性，而是一条道走到黑。

更进一步，树的遍历其实也只是是DFS和BFS的一个特例。

> 值的注意的是，**栈是辅助工具，DFS和BFS才是方法。**

N-皇后算法实际上就是DFS的一个典型应用（当然，N-皇后也是回溯的一个经典例子），在N-皇后算法中，我们可以得到一个**N叉树**，在最基本的情况下，这个树可以视为**满N叉树**，但是由于在实现算法中，我们做了一些处理，即，当某一个位置并不能满足条件时，我们就终止此次递归，因此，N-皇后算法实际并不能得到一个满N叉树。

在不满足情况时，强行终止此次递归，也就是所谓的“***剪枝***”，可以极大的节省算法开销。

> 节省的时间是实际的时间，或者说是**大Θ**的理论时间。
> 我们通常所说的**大O**表示法只是表示算法时间上界，剪枝之后的算法时间可以沿用原来的`O(x)`时间。

此外，还有贪心算法和动态规划，都用到的DFS。

在相对简单的0-1背包问题中，我们只需要考虑要和不要的问题，最终将这个问题转换成求一棵二叉树满足某个条件的路径。可以想到使用DFS去遍历这棵树，但这种方式未必一定符合贪心的原则。

贪心算法是在找当前满足条件的最优解，而DFS遍历树则只是在找寻满足条件的解（他更宽松一些，只要满足条件，而未必是当前的最优情况）。

> 贪心和动态规划最要命的一点是，无法通过暴力法去找到其规律，只能通过去分析问题，将问题划分成**可重复的**&&**最小的**&&**子问题**。
> 不过这种问题划分方式应当属于编写程序的基础，只是在贪心和动态规划**算法**（递归是编写程序的手段/方式）中，这种划分方式显得尤为突出。

### 二分查找

二分查找的在工程上的应用是没怎么见到过，据说在Apriori算法中用到二分查找。

> Apriori算法：挖掘关联规则的频集算法，即判断A集合的子集是否存在于B集合中。

在排序中，有提到过二分插入排序，就是二分查找+直接插入排序，和直接插入排序差不多，只是减少了元素的比较时间，插入元素的时候依旧需要移动数组元素。此外，二叉查找的过程可以生成一棵树，并且毫无疑问，这棵树就是一棵二叉树搜索树。