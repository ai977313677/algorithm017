学习笔记

### 递归

递归模板：

```javascript
function retrive(...param) {
    // 1. 递归出口
    if (condition) { return ; }

    // 2. 当前层处理
    // 3. 递归调用
    // 4. 清除当前层无用信息
}
```

如上述，递归的模板十分简单，十分容易理解，但实际上，递归是相对难掌握的一个内容，原因主要是手动递归。

在编写或阅读程序的时候，会下意识的生成一个测试用例，运行程序，通常阅读程序的时候，这种行为并不会阻碍我们理解，甚至可能会加深对程序的理解。但是递归程序不一样，他是不断的将一个问题拆分，直到生成的子问题无法继续进行拆分时，开始处理这个最小的子问题，子问题解决之后，将其答案进行归纳，最终得出一个答案。

> **注意**：
>
> 1. 对于每一个最小的子问题，递归程序处理逻辑是一样的。
>
> 2. 即使所有的最小子问题解决之后，并不意味着整个问题的解决，因为每一个子问题都是由更高一级的问题拆分而来。
>
> 3. 一棵树是由根结点以及子树构成，子树的定义也是如此。绘制递归的过程，会得到一棵树，**值得注意的是，这棵树并不是特殊的树（如二叉树，满叉树），而是一棵任意的树。**

通常可以使用数学归纳法来验证递归算法的正确性。

> 即使手工运行递归程序时，也不应该直接使用用例的整体，而应该根据递归程序划分出来的子问题，对测试用例的局部进行分析。此外，需要养成自顶向下的编程方式，因为这是比较符合我们思维的方式，我们总是要先确定自己需要什么，然后才会去创造对应的物品。

### 分治、回溯

分治是将一个问题拆解成多个问题，直到划分到指定大小的问题，对其进行计算解决。

代码模板：

```javascript
function divide(problem, ...param) {
    // 指定的问题大小
    if (problem == null) {
        // 计算结果返回
        return ;
    }

    // 问题划分（处理当前问题）
    subproblems = splitProblem(problem, param);
    sub1 = divide(subproblems[0], param[0]);
    sub2 = divide(subproblems[1], param[1]);
    sub3 = divide(subproblems[2], param[2]);
    ...

    // 合并子问题结果
    result = processResult(sub1, sub2, sub3, ...);

    return result;
}
```

从模板中可以看出来，分治和递归联系上是比较密切的，分治实际上也是在找一个重复的子问题。

在大数据中，经常会有拆分计算的问题，如Java中的MapReduce。

回溯依旧是递归思想，事实上，当某一层递归调用结束返回到上一层时，这就是回溯。

> 最典型的递归和回溯是DFS算法。N-皇后是一个经典的运用回溯法解决的问题。
>
> 在数学中，有一个划分完备集的概念，类似分治的思想。

实际上，只要理解了递归的思想，分治、回溯问题也就迎刃而解。